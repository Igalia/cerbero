From cfec77a805321a4d55954f0c7466f4f8c34a2f29 Mon Sep 17 00:00:00 2001
From: Philippe Normand <philn@igalia.com>
Date: Wed, 7 Sep 2022 03:16:19 -0700
Subject: [PATCH 10/25] Merge 254223@main - [GStreamer] WebAudio drums demo
 makes WebKit GStreamer based ports crash
 https://bugs.webkit.org/show_bug.cgi?id=244841

Reviewed by Xabier Rodriguez-Calvar.

The main issue was a mix-up between channel index and channel types. The m_buffers hash table stores
buffers by channel type, so when we need to copy the data to the bus, we need to use
AudioBus::channelByType().

* Source/WebCore/platform/audio/gstreamer/AudioFileReaderGStreamer.cpp:
(WebCore::channelTypeFromCaps):
(WebCore::AudioFileReader::handleSample):
(WebCore::AudioFileReader::handleNewDeinterleavePad):
(WebCore::AudioFileReader::createBus):

Canonical link: https://commits.webkit.org/254223@main

(cherry picked from commit 2aa13bb90ada0abbfe5ec6e6ad1fcc95c798a361)
---
 .../gstreamer/AudioFileReaderGStreamer.cpp    | 64 +++++++++++++------
 1 file changed, 45 insertions(+), 19 deletions(-)

diff --git a/Source/WebCore/platform/audio/gstreamer/AudioFileReaderGStreamer.cpp b/Source/WebCore/platform/audio/gstreamer/AudioFileReaderGStreamer.cpp
index 87e9e93950b7..50d5e2a690ce 100644
--- a/Source/WebCore/platform/audio/gstreamer/AudioFileReaderGStreamer.cpp
+++ b/Source/WebCore/platform/audio/gstreamer/AudioFileReaderGStreamer.cpp
@@ -78,6 +78,7 @@ private:
     int m_channels { 0 };
     HashMap<int, GRefPtr<GstBufferList>> m_buffers;
     GRefPtr<GstElement> m_pipeline;
+    std::optional<int> m_firstChannelType;
     unsigned m_channelSize { 0 };
     GRefPtr<GstElement> m_decodebin;
     GRefPtr<GstElement> m_deInterleave;
@@ -141,20 +142,8 @@ AudioFileReader::~AudioFileReader()
     }
 }
 
-GstFlowReturn AudioFileReader::handleSample(GstAppSink* sink)
+static inline std::optional<int> channelTypeFromCaps(GstCaps* caps)
 {
-    auto sample = adoptGRef(gst_app_sink_try_pull_sample(sink, 0));
-    if (!sample)
-        return gst_app_sink_is_eos(sink) ? GST_FLOW_EOS : GST_FLOW_ERROR;
-
-    GstBuffer* buffer = gst_sample_get_buffer(sample.get());
-    if (!buffer)
-        return GST_FLOW_ERROR;
-
-    GstCaps* caps = gst_sample_get_caps(sample.get());
-    if (!caps)
-        return GST_FLOW_ERROR;
-
     int channelId = 0;
     GstAudioInfo info;
     gst_audio_info_from_caps(&info, caps);
@@ -182,14 +171,44 @@ GstFlowReturn AudioFileReader::handleSample(GstAppSink* sink)
         break;
     default:
         GST_WARNING("Unhandled channel: %d", GST_AUDIO_INFO_POSITION(&info, 0));
-        return GST_FLOW_ERROR;
+        return { };
     };
+    return channelId;
+}
 
-    channelId++;
-    if (channelId == 1)
+GstFlowReturn AudioFileReader::handleSample(GstAppSink* sink)
+{
+    auto sample = adoptGRef(gst_app_sink_try_pull_sample(sink, 0));
+    if (!sample)
+        return gst_app_sink_is_eos(sink) ? GST_FLOW_EOS : GST_FLOW_ERROR;
+
+    GstBuffer* buffer = gst_sample_get_buffer(sample.get());
+    if (!buffer)
+        return GST_FLOW_ERROR;
+
+    GstCaps* caps = gst_sample_get_caps(sample.get());
+    if (!caps)
+        return GST_FLOW_ERROR;
+
+    auto channelType = channelTypeFromCaps(caps);
+    if (!channelType)
+        return GST_FLOW_ERROR;
+
+    if (!m_firstChannelType) {
+        ASSERT_NOT_REACHED();
+        return GST_FLOW_ERROR;
+    }
+
+    if (*channelType == *m_firstChannelType) {
+        GstAudioInfo info;
+        gst_audio_info_from_caps(&info, caps);
         m_channelSize += gst_buffer_get_size(buffer) / info.bpf;
+    }
 
-    auto result = m_buffers.ensure(channelId, [] {
+    // Shift hash table key values by one, otherwise we would hit an ASSERT here when channelType is
+    // 0 (Left), which is also KeyTraits::emptyValue() which is not allowed.
+    int keyId = *channelType + 1;
+    auto result = m_buffers.ensure(keyId, [] {
         return adoptGRef(gst_buffer_list_new());
     });
     auto& bufferList = result.iterator->value;
@@ -249,6 +268,12 @@ void AudioFileReader::handleNewDeinterleavePad(GstPad* pad)
     // ... deinterleave ! appsink.
     GstElement* sink = makeGStreamerElement("appsink", nullptr);
 
+    if (!m_firstChannelType) {
+        auto caps = adoptGRef(gst_pad_query_caps(pad, nullptr));
+        auto channelType = channelTypeFromCaps(caps.get());
+        if (channelType)
+            m_firstChannelType = WTFMove(channelType);
+    }
     m_channels++;
 
     static GstAppSinkCallbacks callbacks = {
@@ -395,8 +420,9 @@ RefPtr<AudioBus> AudioFileReader::createBus(float sampleRate, bool mixToMono)
     auto audioBus = AudioBus::create(m_channels, m_channelSize, true);
     audioBus->setSampleRate(m_sampleRate);
 
-    for (auto& it : m_buffers)
-        copyGstreamerBuffersToAudioChannel(it.value, audioBus->channel(it.key - 1));
+    for (auto& [key, buffer] : m_buffers)
+        copyGstreamerBuffersToAudioChannel(buffer, audioBus->channelByType(key - 1));
+
     m_buffers.clear();
 
     if (mixToMono)
-- 
2.37.3

